===
[Pattern matching] simple
===
> match f with
    "Pie"     -> "slice"
    "Coffee"  -> "cup"
    "Soup"    -> "bowl"
    "Pancake" -> "stack"
    _         -> "???"
---

(unison
  (watch_expression
    (block_term
      (match_expression
        (match)
        (regular_identifier)
        (with)
        (pattern_case
          (pattern
            (literal_text))
          (arrow_symbol)
          (block_term
            (literal_text)))
        (pattern_case
          (pattern
            (literal_text))
          (arrow_symbol)
          (block_term
            (literal_text)))
        (pattern_case
          (pattern
            (literal_text))
          (arrow_symbol)
          (block_term
            (literal_text)))
        (pattern_case
          (pattern
            (literal_text))
          (arrow_symbol)
          (block_term
            (literal_text)))
        (pattern_case
          (pattern
            (blank_pattern))
          (arrow_symbol)
          (block_term
            (literal_text)))))))

===
[Pattern matching] with variables
===
> match guess with
    42 -> "magic"
    n -> "not magic"
---

(unison
  (watch_expression
    (block_term
      (match_expression
        (match)
        (regular_identifier)
        (with)
        (pattern_case
          (pattern
            (nat))
          (arrow_symbol)
          (block_term
            (literal_text)))
        (pattern_case
          (pattern
            (var_or_nullary_ctor
              (regular_identifier)))
          (arrow_symbol)
          (block_term
            (literal_text)))))))

===
[Pattern matching] guard patterns
===
> cases
    oneTwo | (oneTwo === 1) || (oneTwo === 2) -> "one or two"
---

(unison
  (watch_expression
    (block_term
      (match_expression_lambda
        (cases)
        (pattern_case
          (pattern
            (var_or_nullary_ctor
              (regular_identifier)))
          (guarded_block
            (pipe)
            (guard
              (tuple_or_parenthesized
                (regular_identifier)
                (operator)
                (nat))
              (or)
              (tuple_or_parenthesized
                (regular_identifier)
                (operator)
                (nat)))
            (arrow_symbol)
            (block_term
              (literal_text))))))))

===
[Pattern matching] guard pattern 2
===
> match x with
     0 | 1 == 2 -> 123
---

(unison
  (watch_expression
    (block_term
      (match_expression
        (match)
        (regular_identifier)
        (with)
        (pattern_case
          (pattern
            (nat))
          (guarded_block
            (pipe)
            (guard
              (nat)
              (operator)
              (nat))
            (arrow_symbol)
            (block_term
              (nat))))))))

===
[Patterns] match x -> x
===
> match x with x -> x
---

(unison
  (watch_expression
    (block_term
      (match_expression
        (match)
        (regular_identifier)
        (with)
        (pattern_case
          (pattern
            (var_or_nullary_ctor
              (regular_identifier)))
          (arrow_symbol)
          (block_term
            (regular_identifier)))))))

===
[Patterns] match 0 -> 1
===
> match x with 0 -> 1
---

(unison
  (watch_expression
    (block_term
      (match_expression
        (match)
        (regular_identifier)
        (with)
        (pattern_case
          (pattern
            (nat))
          (arrow_symbol)
          (block_term
            (nat)))))))

===
[Patterns] pattern with newline layout
===
> cases
    0 -> 1
---

(unison
  (watch_expression
    (block_term
      (match_expression_lambda
        (cases)
        (pattern_case
          (pattern
            (nat))
          (arrow_symbol)
          (block_term
            (nat)))))))

===
[Patterns] matching on int
===
> match +0 with
      +0 -> -1
---

(unison
  (watch_expression
    (block_term
      (match_expression
        (match)
        (int)
        (with)
        (pattern_case
          (pattern
            (int))
          (arrow_symbol)
          (block_term
            (int)))))))

===
[Patterns] blank pattern
===
> cases _ -> 1
---

(unison
  (watch_expression
    (block_term
      (match_expression_lambda
        (cases)
        (pattern_case
          (pattern
            (blank_pattern))
          (arrow_symbol)
          (block_term
            (nat)))))))

===
[Patterns] multiple patterns
===
> cases
      x -> 1
      2 -> 7
---

(unison
  (watch_expression
    (block_term
      (match_expression_lambda
        (cases)
        (pattern_case
          (pattern
            (var_or_nullary_ctor
              (regular_identifier)))
          (arrow_symbol)
          (block_term
            (nat)))
        (pattern_case
          (pattern
            (nat))
          (arrow_symbol)
          (block_term
            (nat)))))))

===
[Patterns] constructor pattern
===
> cases Tuple.Cons x y -> ()
---

(unison
  (watch_expression
    (block_term
      (match_expression_lambda
        (cases)
        (pattern_case
          (pattern
            (var_or_nullary_ctor
              (path)
              (regular_identifier))
            (var_or_nullary_ctor
              (regular_identifier))
            (var_or_nullary_ctor
              (regular_identifier)))
          (arrow_symbol)
          (block_term
            (unit)))))))

===
[Patterns] nested pattern
===
> cases Tuple.Cons (Tuple.Cons x y) _ -> ()
---

(unison
  (watch_expression
    (block_term
      (match_expression_lambda
        (cases)
        (pattern_case
          (pattern
            (var_or_nullary_ctor
              (path)
              (regular_identifier))
            (parenthesized_or_tuple_pattern
              (open_parens)
              (pattern
                (var_or_nullary_ctor
                  (path)
                  (regular_identifier))
                (var_or_nullary_ctor
                  (regular_identifier))
                (var_or_nullary_ctor
                  (regular_identifier)))
              (close_parens))
            (blank_pattern))
          (arrow_symbol)
          (block_term
            (unit)))))))

===
[Patterns] newline layout for post-arrow block of RHS of pattern
===
> cases
      0 ->
        z = 0
        z
---

(unison
  (watch_expression
    (block_term
      (match_expression_lambda
        (cases)
        (pattern_case
          (pattern
            (nat))
          (arrow_symbol)
          (term_declaration
            (term_definition
              (regular_identifier)
              (kw_equals)
              (block_term
                (nat))))
          (block_term
            (regular_identifier)))))))

===
[Patterns] empty list literal
===
> cases [] -> 0
---

(unison
  (watch_expression
    (block_term
      (match_expression_lambda
        (cases)
        (pattern_case
          (pattern
            (literal_list_pattern))
          (arrow_symbol)
          (block_term
            (nat)))))))

===
[Patterns] cons pattern
===
> cases 2 +: 2 -> 2
---

(unison
  (watch_expression
    (block_term
      (match_expression_lambda
        (cases)
        (pattern_case
          (pattern
            (nat))
          (cons)
          (pattern
            (nat))
          (arrow_symbol)
          (block_term
            (nat)))))))

===
[Patterns] singleton list
===
> cases [1] -> 1
---

(unison
  (watch_expression
    (block_term
      (match_expression_lambda
        (cases)
        (pattern_case
          (pattern
            (literal_list_pattern
              (pattern
                (nat))))
          (arrow_symbol)
          (block_term
            (nat)))))))

===
[Patterns] snoc pattern
===
> cases _ :+ 3 -> 3
---

(unison
  (watch_expression
    (block_term
      (match_expression_lambda
        (cases)
        (pattern_case
          (pattern
            (blank_pattern))
          (snoc)
          (pattern
            (nat))
          (arrow_symbol)
          (block_term
            (nat)))))))

===
[Patterns] concat pattern
===
> cases [4] ++ _ -> 4
---

(unison
  (watch_expression
    (block_term
      (match_expression_lambda
        (cases)
        (pattern_case
          (pattern
            (literal_list_pattern
              (pattern
                (nat))))
          (concat)
          (pattern
            (blank_pattern))
          (arrow_symbol)
          (block_term
            (nat)))))))

===
[Patterns] cases (aka "lambda") pattern matching
===
> cases [] -> 0
---

(unison
  (watch_expression
    (block_term
      (match_expression_lambda
        (cases)
        (pattern_case
          (pattern
            (literal_list_pattern))
          (arrow_symbol)
          (block_term
            (nat)))))))

===
[Patterns] cases returning tuple expression
===
> cases (x, y) -> (y, x)
---

(unison
  (watch_expression
    (block_term
      (match_expression_lambda
        (cases)
        (pattern_case
          (pattern
            (parenthesized_or_tuple_pattern
              (open_parens)
              (pattern
                (var_or_nullary_ctor
                  (regular_identifier)))
              (comma)
              (pattern
                (var_or_nullary_ctor
                  (regular_identifier)))
              (close_parens)))
          (arrow_symbol)
          (block_term
            (tuple_or_parenthesized
              (regular_identifier)
              (regular_identifier))))))))
