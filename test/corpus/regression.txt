===
infix op functional expression not parsed as such
===
x = 1 + 2
---

(unison
  (term_declaration
    (term_definition
      (regular_identifier)
      (kw_equals)
      (block_term
        (nat)
        (operator)
        (nat)))))

===
[Regression] Issue 21: built-in hash without path not parsed correctly
===
x = ##Foo
---

(unison
  (term_declaration
    (term_definition
      (regular_identifier)
      (kw_equals)
      (block_term
        (built_in_hash)))))

===
[Regression] issue 24: multiline text literal with an unescaped double quotation mark
===
> """ foo " bar """
---

(unison
  (watch_expression
    (block_term
      (literal_text))))

===
[Regression] Issue 30, infix ops with path in function application
===
> 1 Nat.+ 2
---

(unison
  (watch_expression
    (block_term
      (nat)
      (path)
      (operator)
      (nat))))

===
[Regression] #34 - watch expressions can be binds (term definitions, but types are not allowed as per TermParser.hs, so not term declarations). They cannot be destructuring binds, which cannot happen at the top level. Verified via Unison LSP.
===
> z = 5
---

(unison
  (watch_expression
    (term_declaration
      (term_definition
        (regular_identifier)
        (kw_equals)
        (block_term
          (nat))))))

===
[Regression] Issue 37, docblock can be anywhere an expression is
===
z = {{ test }}
---

(unison
  (term_declaration
    (term_definition
      (regular_identifier)
      (kw_equals)
      (block_term
        (doc_block)))))

===
[Regression] Issue 37, anonymous docblock immediately precedes term declaration
===
{{ howdy }}
x = 5
---

(unison
  (term_declaration
    (doc_block)
    (term_definition
      (regular_identifier)
      (kw_equals)
      (block_term
        (nat)))))

===
[Regression] Issue 39, Parenthesized operators in term declaration (def'n + type sig) fail
===
(Numeric.>=) : Numeric -> Numeric -> Boolean
(Numeric.>=) = todo "implement"
---

(unison
  (term_declaration
    (type_signature
      (open_parens)
      (path)
      (operator)
      (close_parens)
      (type_signature_colon)
      (term_type
        (regular_identifier)
        (arrow_symbol)
        (regular_identifier)
        (arrow_symbol)
        (regular_identifier)))
    (term_definition
      (open_parens)
      (path)
      (operator)
      (close_parens)
      (kw_equals)
      (block_term
        (regular_identifier)
        (literal_text)))))

===
[Regression] Issue 46, comment that appears where a fold could be fails
===
-- this is a comment
---

(unison
  (comment))

===
[Regression] #82
===
-- builtin lib.base.Float.fromNat : lib.base.Nat -> lib.base.Float

lib.base.Float.fromNat.doc : Doc
lib.base.Float.fromNat.doc =
  use Float fromNat
  {{
  Convert a {type Nat} to a {type Float}.

  # Examples

    ```
    fromNat 3
    ```

    ```
    fromNat maxNat
    ```
  }}
---

(unison
  (comment)
  (term_declaration
    (type_signature
      (path)
      (regular_identifier)
      (type_signature_colon)
      (term_type
        (regular_identifier)))
    (term_definition
      (path)
      (regular_identifier)
      (kw_equals)
      (use_clause
        (use)
        (namespace
          (regular_identifier))
        (regular_identifier))
      (block_term
        (doc_block)))))

===
[Regression] 84 path with symboly id fails
===
lib.base.Nat.!=.doc = 5
---

(unison
  (term_declaration
    (term_definition
      (path)
      (regular_identifier)
      (kw_equals)
      (block_term
        (nat)))))

===
[Regression] pattern matching guards should be part of a layouted block
===
> match true with
      a
        | true  ->
            1
        | otherwise -> 5
---

(unison
  (watch_expression
    (block_term
      (match_expression
        (match)
        (literal_boolean)
        (with)
        (pattern_case
          (pattern
            (var_or_nullary_ctor
              (regular_identifier)))
          (guarded_block
            (pipe)
            (guard
              (literal_boolean))
            (arrow_symbol)
            (block_term
              (nat)))
          (guarded_block
            (pipe)
            (guard
              (otherwise))
            (arrow_symbol)
            (block_term
              (nat))))))))

===
[Regression] #91 - infix op can have namespace prefix
===
a lib.base.Nat.!= b =
  use Nat ==
  Boolean.not (a == b)
---

(unison
  (term_declaration
    (term_definition
      (regular_identifier)
      (path)
      (operator)
      (regular_identifier)
      (kw_equals)
      (use_clause
        (use)
        (namespace
          (regular_identifier))
        (operator))
      (block_term
        (path)
        (regular_identifier)
        (tuple_or_parenthesized
          (regular_identifier)
          (operator)
          (regular_identifier))))))

===
[Regression] watch doc block fails to parse
===
> {{}}
---

(unison
  (watch_expression
    (block_term
      (doc_block))))

===
[Regression] #103, match scrutinee should be term
===
> match foo hit with
      _   -> a
---

(unison
  (watch_expression
    (block_term
      (match_expression
        (match)
        (regular_identifier)
        (regular_identifier)
        (with)
        (pattern_case
          (pattern
            (blank_pattern))
          (arrow_symbol)
          (block_term
            (regular_identifier)))))))

===
[Regression] fold that is more than just ---
===
----This starts a fold
this should still be fold
---

(unison
  (fold))

===
[Regression] <| operator
===
> a <| b
---

(unison
  (watch_expression
    (block_term
      (regular_identifier)
      (operator)
      (regular_identifier))))

===
[Regression] 2-symbol op ending with &
===
> a <& b
---

(unison
  (watch_expression
    (block_term
      (regular_identifier)
      (operator)
      (regular_identifier))))

===
[Regression] Issue 121: pattern following effect pattern fails to be recognized as a pattern
===
a = cases
    { a } -> 2
    a -> 2
---

(unison
  (term_declaration
    (term_definition
      (regular_identifier)
      (kw_equals)
      (block_term
        (match_expression_lambda
          (cases)
          (pattern_case
            (pattern
              (effect_pattern
                (effect_pure
                  (pattern
                    (var_or_nullary_ctor
                      (regular_identifier))))))
            (arrow_symbol)
            (block_term
              (nat)))
          (pattern_case
            (pattern
              (var_or_nullary_ctor
                (regular_identifier)))
            (arrow_symbol)
            (block_term
              (nat))))))))

===
[Regression] #134 multi-line quotation mark text literal that opens with more than three " needs balanced ending
===
x = """"
foo
bar"""
baz""""
---

(unison
  (term_declaration
    (term_definition
      (regular_identifier)
      (kw_equals)
      (block_term
        (literal_text)))))

===
[Regression] GH-139: underscores in path names
===
lib.unison_base_3_0_0.Nat.gcd = 5
---

(unison
  (term_declaration
    (term_definition
      (path)
      (regular_identifier)
      (kw_equals)
      (block_term
        (nat)))))

===
[Regression] 141 - use clause in block
===
complexCalculation input =
  let
    result = 5
    use Nat + - *
    result
---

(unison
  (term_declaration
    (term_definition
      (regular_identifier)
      (regular_identifier)
      (kw_equals)
      (block_term
        (exp_let
          (kw_let)
          (term_declaration
            (term_definition
              (regular_identifier)
              (kw_equals)
              (block_term
                (nat))))
          (use_clause
            (use)
            (namespace
              (regular_identifier))
            (operator)
            (operator)
            (operator))
          (block_term
            (regular_identifier)))))))

===
[Regression] 141 - use clause in former layout block
===
x =
  (a, b) =
    n = 5
    use c d e
    (1, 2)
  a
---

(unison
  (term_declaration
    (term_definition
      (regular_identifier)
      (kw_equals)
      (destructuring_bind
        (parenthesized_or_tuple_pattern
          (open_parens)
          (pattern
            (var_or_nullary_ctor
              (regular_identifier)))
          (comma)
          (pattern
            (var_or_nullary_ctor
              (regular_identifier)))
          (close_parens))
        (kw_equals)
        (term_declaration
          (term_definition
            (regular_identifier)
            (kw_equals)
            (block_term
              (nat))))
        (use_clause
          (use)
          (namespace
            (regular_identifier))
          (regular_identifier)
          (regular_identifier))
        (block_term
          (tuple_or_parenthesized
            (nat)
            (nat))))
      (block_term
        (regular_identifier)))))

===
[Regression] GH-143 - tuple expr in case branch return
===
swap = cases
  (x, y) -> (y, x)
---

(unison
  (term_declaration
    (term_definition
      (regular_identifier)
      (kw_equals)
      (block_term
        (match_expression_lambda
          (cases)
          (pattern_case
            (pattern
              (parenthesized_or_tuple_pattern
                (open_parens)
                (pattern
                  (var_or_nullary_ctor
                    (regular_identifier)))
                (comma)
                (pattern
                  (var_or_nullary_ctor
                    (regular_identifier)))
                (close_parens)))
            (arrow_symbol)
            (block_term
              (tuple_or_parenthesized
                (regular_identifier)
                (regular_identifier)))))))))

===
[Regression] GH-142 - destructuring bind issue
===
y =
  (x, _) = someFunction()
  x
---

(unison
  (term_declaration
    (term_definition
      (regular_identifier)
      (kw_equals)
      (destructuring_bind
        (parenthesized_or_tuple_pattern
          (open_parens)
          (pattern
            (var_or_nullary_ctor
              (regular_identifier)))
          (comma)
          (pattern
            (blank_pattern))
          (close_parens))
        (kw_equals)
        (block_term
          (force
            (regular_identifier)
            (unit))))
      (block_term
        (regular_identifier)))))

===
[Regression] GH-144 Guarded block
===
x = cases
  n
    | otherwise ->
      n2 = getOrUpdate (n - 2) do fibonacci (n - 2)
      a
---

(unison
  (term_declaration
    (term_definition
      (regular_identifier)
      (kw_equals)
      (block_term
        (match_expression_lambda
          (cases)
          (pattern_case
            (pattern
              (var_or_nullary_ctor
                (regular_identifier)))
            (guarded_block
              (pipe)
              (guard
                (otherwise))
              (arrow_symbol)
              (term_declaration
                (term_definition
                  (regular_identifier)
                  (kw_equals)
                  (block_term
                    (regular_identifier)
                    (tuple_or_parenthesized
                      (regular_identifier)
                      (operator)
                      (nat))
                    (delay_block
                      (do)
                      (block_term
                        (regular_identifier)
                        (tuple_or_parenthesized
                          (regular_identifier)
                          (operator)
                          (nat)))))))
              (block_term
                (regular_identifier)))))))))

===
[Regression] destructuring, unexplained cause
===
a =
  unsafeRun! do
    (Arr a) = arr1
    0
---

(unison
  (term_declaration
    (term_definition
      (regular_identifier)
      (kw_equals)
      (block_term
        (regular_identifier)
        (delay_block
          (do)
          (destructuring_bind
            (parenthesized_or_tuple_pattern
              (open_parens)
              (pattern
                (var_or_nullary_ctor
                  (regular_identifier))
                (var_or_nullary_ctor
                  (regular_identifier)))
              (close_parens))
            (kw_equals)
            (block_term
              (regular_identifier)))
          (block_term
            (nat)))))))

===
[Regression] GH-145 - 0-ary effect binding pattern
===
a =
  cases
    { b -> c } -> ()
---

(unison
  (term_declaration
    (term_definition
      (regular_identifier)
      (kw_equals)
      (block_term
        (match_expression_lambda
          (cases)
          (pattern_case
            (pattern
              (effect_pattern
                (effect_bind
                  (var_or_nullary_ctor
                    (regular_identifier))
                  (effect_arrow)
                  (pattern
                    (var_or_nullary_ctor
                      (regular_identifier))))))
            (arrow_symbol)
            (block_term
              (unit))))))))

===
[Regression] GH-146 - issue closing layout of do block
===
x = do (a)
---

(unison
  (term_declaration
    (term_definition
      (regular_identifier)
      (kw_equals)
      (block_term
        (delay_block
          (do)
          (block_term
            (tuple_or_parenthesized
              (regular_identifier))))))))

===
[Regression] GH-147 - in-line comments
===
a =
  unsafeRun! -- do
    --(Arr a) --= arr1
    --0
---

(unison
  (term_declaration
    (term_definition
      (regular_identifier)
      (kw_equals)
      (block_term
        (regular_identifier))
      (comment)
      (comment)
      (comment))))

===
GH-155 Void.absurdly
===
Void.absurdly v = match v() with
---

(unison
  (term_declaration
    (term_definition
      (path)
      (regular_identifier)
      (regular_identifier)
      (kw_equals)
      (block_term
        (match_expression
          (match)
          (force
            (regular_identifier)
            (unit))
          (with))))))

===
[Regression] GH-151 - destructuring bind that is an as-pattern fails
===
a =
  Bag.fromOccurrenceList << List.flatMap
    (p -> let
      q@(b, n) = f p
      if Universal.lt n 1 then [] else [q]) << Bag.occurrenceList
---

(unison
  (term_declaration
    (term_definition
      (regular_identifier)
      (kw_equals)
      (block_term
        (path)
        (regular_identifier)
        (operator)
        (path)
        (regular_identifier)
        (tuple_or_parenthesized
          (literal_function
            (regular_identifier)
            (arrow_symbol)
            (exp_let
              (kw_let)
              (destructuring_bind
                (regular_identifier
                  (regular_identifier))
                (at_token)
                (parenthesized_or_tuple_pattern
                  (open_parens)
                  (pattern
                    (var_or_nullary_ctor
                      (regular_identifier)))
                  (comma)
                  (pattern
                    (var_or_nullary_ctor
                      (regular_identifier)))
                  (close_parens))
                (kw_equals)
                (block_term
                  (regular_identifier)
                  (regular_identifier)))
              (block_term
                (exp_if
                  (if_block
                    (kw_if)
                    (block_term
                      (path)
                      (regular_identifier)
                      (regular_identifier)
                      (nat)))
                  (then_block
                    (kw_then)
                    (block_term
                      (literal_list
                        (open_bracket)
                        (close_bracket))))
                  (else_block
                    (kw_else)
                    (block_term
                      (literal_list
                        (open_bracket)
                        (regular_identifier)
                        (close_bracket)))))))))
        (operator)
        (path)
        (regular_identifier)))))

===
[Regression] GH-152 - pattern matching with nested use clause in RHS
===
a = cases
  _ ->
    use foo +
    true
---

(unison
  (term_declaration
    (term_definition
      (regular_identifier)
      (kw_equals)
      (block_term
        (match_expression_lambda
          (cases)
          (pattern_case
            (pattern
              (blank_pattern))
            (arrow_symbol)
            (use_clause
              (use)
              (namespace
                (regular_identifier))
              (operator))
            (block_term
              (literal_boolean))))))))

===
GH-156
===
a =
    if true
    then true
    else
      use Nat / ==
      true
---

(unison
  (term_declaration
    (term_definition
      (regular_identifier)
      (kw_equals)
      (block_term
        (exp_if
          (if_block
            (kw_if)
            (block_term
              (literal_boolean)))
          (then_block
            (kw_then)
            (block_term
              (literal_boolean)))
          (else_block
            (kw_else)
            (use_clause
              (use)
              (namespace
                (regular_identifier))
              (operator)
              (operator))
            (block_term
              (literal_boolean))))))))

===
GH-157 - layout issues with if/then/else
===
a =
  hours = if true then true else true
  true
---

(unison
  (term_declaration
    (term_definition
      (regular_identifier)
      (kw_equals)
      (term_declaration
        (term_definition
          (regular_identifier)
          (kw_equals)
          (block_term
            (exp_if
              (if_block
                (kw_if)
                (block_term
                  (literal_boolean)))
              (then_block
                (kw_then)
                (block_term
                  (literal_boolean)))
              (else_block
                (kw_else)
                (block_term
                  (literal_boolean)))))))
      (block_term
        (literal_boolean)))))

===
GH-154 - pattern LHS representing a multi-param lambda
===
a = cases
  n, UTCOffset o -> UTCOffset (o Int.- Nat.toInt n)
---

(unison
  (term_declaration
    (term_definition
      (regular_identifier)
      (kw_equals)
      (block_term
        (match_expression_lambda
          (cases)
          (pattern_case
            (pattern
              (var_or_nullary_ctor
                (regular_identifier)))
            (comma)
            (pattern
              (var_or_nullary_ctor
                (regular_identifier))
              (var_or_nullary_ctor
                (regular_identifier)))
            (arrow_symbol)
            (block_term
              (regular_identifier)
              (tuple_or_parenthesized
                (regular_identifier)
                (path)
                (operator)
                (path)
                (regular_identifier)
                (regular_identifier)))))))))

===
GH-159 - pattern case RHS should be a layout block
===
a =
  cases
    _ ->
      use Int * +
      ()
---

(unison
  (term_declaration
    (term_definition
      (regular_identifier)
      (kw_equals)
      (block_term
        (match_expression_lambda
          (cases)
          (pattern_case
            (pattern
              (blank_pattern))
            (arrow_symbol)
            (use_clause
              (use)
              (namespace
                (regular_identifier))
              (operator)
              (operator))
            (block_term
              (unit))))))))

===
GH-160 - as pattern in pattern case
===
a : b -> c
a = cases
  o@(UTCOffset new) -> a
---

(unison
  (term_declaration
    (type_signature
      (regular_identifier)
      (type_signature_colon)
      (term_type
        (regular_identifier)
        (arrow_symbol)
        (regular_identifier)))
    (term_definition
      (regular_identifier)
      (kw_equals)
      (block_term
        (match_expression_lambda
          (cases)
          (pattern_case
            (pattern
              (var_or_nullary_ctor
                (regular_identifier))
              (at_token)
              (parenthesized_or_tuple_pattern
                (open_parens)
                (pattern
                  (var_or_nullary_ctor
                    (regular_identifier))
                  (var_or_nullary_ctor
                    (regular_identifier)))
                (close_parens)))
            (arrow_symbol)
            (block_term
              (regular_identifier))))))))

===
GH-161 - typedef consumes start of following termdef
===
time.UTCOffset.fromIso8601 : Text -> Optional UTCOffset
time.UTCOffset.fromIso8601 t =
  toOptional! do match Optional.toAbort (Pattern.run iso8601Timezone t) with
    _                          -> abort
---

(unison
  (term_declaration
    (type_signature
      (path)
      (regular_identifier)
      (type_signature_colon)
      (term_type
        (regular_identifier)
        (arrow_symbol)
        (regular_identifier)
        (regular_identifier)))
    (term_definition
      (path)
      (regular_identifier)
      (regular_identifier)
      (kw_equals)
      (block_term
        (regular_identifier)
        (delay_block
          (do)
          (block_term
            (match_expression
              (match)
              (path)
              (regular_identifier)
              (tuple_or_parenthesized
                (path)
                (regular_identifier)
                (regular_identifier)
                (regular_identifier))
              (with)
              (pattern_case
                (pattern
                  (blank_pattern))
                (arrow_symbol)
                (block_term
                  (regular_identifier))))))))))

===
GH-162
===
a d =
  match () with
    ()
      | otherwise         -> ()
---

(unison
  (term_declaration
    (term_definition
      (regular_identifier)
      (regular_identifier)
      (kw_equals)
      (block_term
        (match_expression
          (match)
          (unit)
          (with)
          (pattern_case
            (pattern
              (parenthesized_or_tuple_pattern
                (open_parens)
                (close_parens)))
            (guarded_block
              (pipe)
              (guard
                (otherwise))
              (arrow_symbol)
              (block_term
                (unit)))))))))

===
GH-163
===
a = b do
  x = atLeastOne (gen.oneOf [?., ?-]) ()
  true
---

(unison
  (term_declaration
    (term_definition
      (regular_identifier)
      (kw_equals)
      (block_term
        (regular_identifier)
        (delay_block
          (do)
          (term_declaration
            (term_definition
              (regular_identifier)
              (kw_equals)
              (block_term
                (regular_identifier)
                (tuple_or_parenthesized
                  (path)
                  (regular_identifier)
                  (literal_list
                    (open_bracket)
                    (literal_char)
                    (literal_char)
                    (close_bracket)))
                (unit))))
          (block_term
            (literal_boolean)))))))

===
GH-172
===
a =
  totalSize = Bytes.size bytes
  a
---

(unison
  (term_declaration
    (term_definition
      (regular_identifier)
      (kw_equals)
      (term_declaration
        (term_definition
          (regular_identifier)
          (kw_equals)
          (block_term
            (path)
            (regular_identifier)
            (regular_identifier))))
      (block_term
        (regular_identifier)))))

===
GH-173
===
metadata.licenses.fböller2020.doc : Doc
metadata.licenses.fböller2020.doc = License.toDoc fböller2020
---

(unison
  (term_declaration
    (type_signature
      (path)
      (regular_identifier)
      (type_signature_colon)
      (term_type
        (regular_identifier)))
    (term_definition
      (path)
      (regular_identifier)
      (kw_equals)
      (block_term
        (path)
        (regular_identifier)
        (regular_identifier)))))

===
GH-174
===
math.Natural.internal.normalize : Natural -> Natural
math.Natural.internal.normalize =
  use Nat ==
  lmask = bitMask
  hmask = Nat.complement lmask
  cases
    Natural ns ->
      rec rem done carry = match rem with
        []      ->
          done' = List.dropRightWhile (x -> x == 0) done
          if carry == 0 then mkNatural done' else mkNatural (done' :+ carry)
        x +: xs -> go xs x done carry
      go rem next done carry =
        use Nat + <= and
        newNext = next + carry
        if newNext <= lmask then rec rem (done :+ newNext) 0
        else
          newNewNext = and lmask newNext
          newCarry = Nat.shiftRight (and hmask newNext) bitWidth
          rec rem (done :+ newNewNext) newCarry
      go (Nonempty.tail ns) (Nonempty.head ns) [] 0
---

(unison
  (term_declaration
    (type_signature
      (path)
      (regular_identifier)
      (type_signature_colon)
      (term_type
        (regular_identifier)
        (arrow_symbol)
        (regular_identifier)))
    (term_definition
      (path)
      (regular_identifier)
      (kw_equals)
      (use_clause
        (use)
        (namespace
          (regular_identifier))
        (operator))
      (term_declaration
        (term_definition
          (regular_identifier)
          (kw_equals)
          (block_term
            (regular_identifier))))
      (term_declaration
        (term_definition
          (regular_identifier)
          (kw_equals)
          (block_term
            (path)
            (regular_identifier)
            (regular_identifier))))
      (block_term
        (match_expression_lambda
          (cases)
          (pattern_case
            (pattern
              (var_or_nullary_ctor
                (regular_identifier))
              (var_or_nullary_ctor
                (regular_identifier)))
            (arrow_symbol)
            (term_declaration
              (term_definition
                (regular_identifier)
                (regular_identifier)
                (regular_identifier)
                (regular_identifier)
                (kw_equals)
                (block_term
                  (match_expression
                    (match)
                    (regular_identifier)
                    (with)
                    (pattern_case
                      (pattern
                        (literal_list_pattern))
                      (arrow_symbol)
                      (term_declaration
                        (term_definition
                          (regular_identifier)
                          (kw_equals)
                          (block_term
                            (path)
                            (regular_identifier)
                            (tuple_or_parenthesized
                              (literal_function
                                (regular_identifier)
                                (arrow_symbol)
                                (regular_identifier)
                                (operator)
                                (nat)))
                            (regular_identifier))))
                      (block_term
                        (exp_if
                          (if_block
                            (kw_if)
                            (block_term
                              (regular_identifier)
                              (operator)
                              (nat)))
                          (then_block
                            (kw_then)
                            (block_term
                              (regular_identifier)
                              (regular_identifier)))
                          (else_block
                            (kw_else)
                            (block_term
                              (regular_identifier)
                              (tuple_or_parenthesized
                                (regular_identifier)
                                (operator)
                                (regular_identifier)))))))
                    (pattern_case
                      (pattern
                        (var_or_nullary_ctor
                          (regular_identifier)))
                      (cons)
                      (pattern
                        (var_or_nullary_ctor
                          (regular_identifier)))
                      (arrow_symbol)
                      (block_term
                        (regular_identifier)
                        (regular_identifier)
                        (regular_identifier)
                        (regular_identifier)
                        (regular_identifier)))))))
            (term_declaration
              (term_definition
                (regular_identifier)
                (regular_identifier)
                (regular_identifier)
                (regular_identifier)
                (regular_identifier)
                (kw_equals)
                (use_clause
                  (use)
                  (namespace
                    (regular_identifier))
                  (operator)
                  (operator)
                  (regular_identifier))
                (term_declaration
                  (term_definition
                    (regular_identifier)
                    (kw_equals)
                    (block_term
                      (regular_identifier)
                      (operator)
                      (regular_identifier))))
                (block_term
                  (exp_if
                    (if_block
                      (kw_if)
                      (block_term
                        (regular_identifier)
                        (operator)
                        (regular_identifier)))
                    (then_block
                      (kw_then)
                      (block_term
                        (regular_identifier)
                        (regular_identifier)
                        (tuple_or_parenthesized
                          (regular_identifier)
                          (operator)
                          (regular_identifier))
                        (nat)))
                    (else_block
                      (kw_else)
                      (term_declaration
                        (term_definition
                          (regular_identifier)
                          (kw_equals)
                          (block_term
                            (regular_identifier)
                            (regular_identifier)
                            (regular_identifier))))
                      (term_declaration
                        (term_definition
                          (regular_identifier)
                          (kw_equals)
                          (block_term
                            (path)
                            (regular_identifier)
                            (tuple_or_parenthesized
                              (regular_identifier)
                              (regular_identifier)
                              (regular_identifier))
                            (regular_identifier))))
                      (block_term
                        (regular_identifier)
                        (regular_identifier)
                        (tuple_or_parenthesized
                          (regular_identifier)
                          (operator)
                          (regular_identifier))
                        (regular_identifier)))))))
            (block_term
              (regular_identifier)
              (tuple_or_parenthesized
                (path)
                (regular_identifier)
                (regular_identifier))
              (tuple_or_parenthesized
                (path)
                (regular_identifier)
                (regular_identifier))
              (literal_list
                (open_bracket)
                (close_bracket))
              (nat))))))))

===
GH-175
===
IO.concurrent.STM.TMap.delete : Bytes -> TMap a ->{STM} ()
IO.concurrent.STM.TMap.delete b tm =
  use F Empty
  use Nat +
  use TVar read write
  go i b m =
    match (Bytes.at i b, m) with
      (None, TMap tv _) -> write tv None
      (Some h, TMap _ children) ->
        child = List.unsafeAt h children
        match read child with
          One b2 a0
            | b === b2   -> write child Empty
            | otherwise  ->
              c = TMap.empty()
              write child (Many c)
              insert.impl (i + 1) b2 c
              go (i + 1) b c
          Many m@(TMap tv children) ->
            go (i + 1) b m
            isEmpty c = match read c with
              Empty -> true
              _     -> false
            if List.all isEmpty children && isNone (read tv) then
              write child Empty
            else ()
          Empty -> ()
  go 0 b tm
---

(unison
  (term_declaration
    (type_signature
      (path)
      (regular_identifier)
      (type_signature_colon)
      (term_type
        (regular_identifier)
        (arrow_symbol)
        (regular_identifier)
        (regular_identifier)
        (arrow_symbol)
        (effect
          (regular_identifier))
        (unit)))
    (term_definition
      (path)
      (regular_identifier)
      (regular_identifier)
      (regular_identifier)
      (kw_equals)
      (use_clause
        (use)
        (namespace
          (regular_identifier))
        (regular_identifier))
      (use_clause
        (use)
        (namespace
          (regular_identifier))
        (operator))
      (use_clause
        (use)
        (namespace
          (regular_identifier))
        (regular_identifier)
        (regular_identifier))
      (term_declaration
        (term_definition
          (regular_identifier)
          (regular_identifier)
          (regular_identifier)
          (regular_identifier)
          (kw_equals)
          (block_term
            (match_expression
              (match)
              (tuple_or_parenthesized
                (path)
                (regular_identifier)
                (regular_identifier)
                (regular_identifier)
                (regular_identifier))
              (with)
              (pattern_case
                (pattern
                  (parenthesized_or_tuple_pattern
                    (open_parens)
                    (pattern
                      (var_or_nullary_ctor
                        (regular_identifier)))
                    (comma)
                    (pattern
                      (var_or_nullary_ctor
                        (regular_identifier))
                      (var_or_nullary_ctor
                        (regular_identifier))
                      (blank_pattern))
                    (close_parens)))
                (arrow_symbol)
                (block_term
                  (regular_identifier)
                  (regular_identifier)
                  (regular_identifier)))
              (pattern_case
                (pattern
                  (parenthesized_or_tuple_pattern
                    (open_parens)
                    (pattern
                      (var_or_nullary_ctor
                        (regular_identifier))
                      (var_or_nullary_ctor
                        (regular_identifier)))
                    (comma)
                    (pattern
                      (var_or_nullary_ctor
                        (regular_identifier))
                      (blank_pattern)
                      (var_or_nullary_ctor
                        (regular_identifier)))
                    (close_parens)))
                (arrow_symbol)
                (term_declaration
                  (term_definition
                    (regular_identifier)
                    (kw_equals)
                    (block_term
                      (path)
                      (regular_identifier)
                      (regular_identifier)
                      (regular_identifier))))
                (block_term
                  (match_expression
                    (match)
                    (regular_identifier)
                    (regular_identifier)
                    (with)
                    (pattern_case
                      (pattern
                        (var_or_nullary_ctor
                          (regular_identifier))
                        (var_or_nullary_ctor
                          (regular_identifier))
                        (var_or_nullary_ctor
                          (regular_identifier)))
                      (guarded_block
                        (pipe)
                        (guard
                          (regular_identifier)
                          (operator)
                          (regular_identifier))
                        (arrow_symbol)
                        (block_term
                          (regular_identifier)
                          (regular_identifier)
                          (regular_identifier)))
                      (guarded_block
                        (pipe)
                        (guard
                          (otherwise))
                        (arrow_symbol)
                        (term_declaration
                          (term_definition
                            (regular_identifier)
                            (kw_equals)
                            (block_term
                              (force
                                (path)
                                (regular_identifier)
                                (unit)))))
                        (block_term
                          (regular_identifier)
                          (regular_identifier)
                          (tuple_or_parenthesized
                            (regular_identifier)
                            (regular_identifier)))
                        (block_term
                          (path)
                          (regular_identifier)
                          (tuple_or_parenthesized
                            (regular_identifier)
                            (operator)
                            (nat))
                          (regular_identifier)
                          (regular_identifier))
                        (block_term
                          (regular_identifier)
                          (tuple_or_parenthesized
                            (regular_identifier)
                            (operator)
                            (nat))
                          (regular_identifier)
                          (regular_identifier))))
                    (pattern_case
                      (pattern
                        (var_or_nullary_ctor
                          (regular_identifier))
                        (var_or_nullary_ctor
                          (regular_identifier))
                        (at_token)
                        (parenthesized_or_tuple_pattern
                          (open_parens)
                          (pattern
                            (var_or_nullary_ctor
                              (regular_identifier))
                            (var_or_nullary_ctor
                              (regular_identifier))
                            (var_or_nullary_ctor
                              (regular_identifier)))
                          (close_parens)))
                      (arrow_symbol)
                      (block_term
                        (regular_identifier)
                        (tuple_or_parenthesized
                          (regular_identifier)
                          (operator)
                          (nat))
                        (regular_identifier)
                        (regular_identifier))
                      (term_declaration
                        (term_definition
                          (regular_identifier)
                          (regular_identifier)
                          (kw_equals)
                          (block_term
                            (match_expression
                              (match)
                              (regular_identifier)
                              (regular_identifier)
                              (with)
                              (pattern_case
                                (pattern
                                  (var_or_nullary_ctor
                                    (regular_identifier)))
                                (arrow_symbol)
                                (block_term
                                  (literal_boolean)))
                              (pattern_case
                                (pattern
                                  (blank_pattern))
                                (arrow_symbol)
                                (block_term
                                  (literal_boolean)))))))
                      (block_term
                        (exp_if
                          (if_block
                            (kw_if)
                            (block_term
                              (path)
                              (regular_identifier)
                              (regular_identifier)
                              (regular_identifier)
                              (and)
                              (regular_identifier)
                              (tuple_or_parenthesized
                                (regular_identifier)
                                (regular_identifier))))
                          (then_block
                            (kw_then)
                            (block_term
                              (regular_identifier)
                              (regular_identifier)
                              (regular_identifier)))
                          (else_block
                            (kw_else)
                            (block_term
                              (unit))))))
                    (pattern_case
                      (pattern
                        (var_or_nullary_ctor
                          (regular_identifier)))
                      (arrow_symbol)
                      (block_term
                        (unit))))))))))
      (block_term
        (regular_identifier)
        (nat)
        (regular_identifier)
        (regular_identifier)))))
